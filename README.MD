This go package provides functions for encryption and splitting arrays into rndom summons.
Generally, the use is pretty strainghtforward - extract data from `io.Reader` argument, make operations, write data to `io.Writer` argument(s) or vice versa.
Encryption functions also require a `[]byte` key wich should have particular length for each algorhithm (otherwise will return IOError).

`getSeed` is used to get random seed for `math/rand` as the sum of current time and random number from [random.org](https://random.org)

<details>
<summary>
  <code>examples/cmdInterface</code> is a command line tool based on this package. Click to see usage
</summary><br>

Splitting:
* Usage: `bitsplit split <flags> <input file> <output files>`
* `-k <int>` the number of summon files you wish to have, must be at least 2
* The first file name is mandatory. If additional file names are not given they are assigned by default. If they are given there must be at least `-k` of them

Joining:
* Usage: `bitsplit join <flags> <output file> <key files>`
* `-config <config file>` program will be initialized with config file, which should contain the output file name and names of key files. If this flag is present everything else will be ignored.
* Without `-config` the `<output file>` is mandatory

Keygen:
* Usage: `bitsplit keygen <flags> <key file>`
* `-l <int>` byte length of the key. Default 32
* `-f` force rewriting of `<key file>`
* `-hex` save key in hex representation

Encrypting via AES:
* Usage: `bitsplit encrypt aes <flags> (input file) (output file) (key file)`
* `-key <string>` key in hex format
* `-r` input file will be replaced with encrypted version. `(output file)` is not provided with this flag
* `-f` force overwriting
* `-hex` save key in hex representation
* `-reuse-key` checks if `(key file)` exists, and then uses the key from the file or generates new key and writes it to the file. Does nothing if `-key` is specified. Useful for encrypting multiple files. 

Decrypting via AES:
* Usage: `bitsplit decrypt aes <flags> (input file) (output file) (key file)`
* `-key <string>` key in hex format. `(key file)` is not provided with this flag
* `-r` input file will be replaced with decrypted version. `(output file)` is not provided with this flag
* `-f` force overwriting
* `-hex` load key in hex representation
</details>

<details>
  <summary>
    <code>examples/dirlocker</code> is a command line tool to encrypt an entire directory. Click to see usage
  </summary><br>
  
  This tool runs recursively through all files in a directory and encrypts them via randomly generated 32-byte key using AES. Random seed is generated by `bitsplit.GetSeed()`, it can be not reliable enough (see source code). External random support will be added in the future.
  
  The key is stored in hidden file inside a specific directory. The file name is SHA-1 sum of the key all contents of the directory, this exact name is stored in `const LockFileName` file inside locked directory (see source code). During encrypting/decrypting a temporary copy of the directory is stored, so there's no danger of parial encryption. If any errors occur during copying contents of working directory in/out of the temporary directory, they are logged and program exits. The temporary directory is located in `os.TempDir() + "~temp<random number>"` 
  
  Lock a directory:
  * Usage: `dirlocker lock <flags>`
  * `-dir <string>` directory to lock. Default `os.Getwd()`
  * `-keydir <string>` directory to store the key. If not provided, on windows will ask if you want to use your last drive in alphabetical order as `-keydir`. On other systems will result in error
  * It is recommended to use the root of an external drive as keydir
  
  Unlock a directory:
  * Usage: `dirlocker unlock <flags>`
  * `-dir <string>` directory to unlock. Default `os.Getwd()`
  * `-keydir <string>` directory where the key is stored. If not provided, on windows will search for key file through all local drives, and exit if not found. On other systems program will exit.
</details>
